#!/usr/bin/env node

/**
 * Generate Categories Metadata
 * 
 * Reads all JSON files from propData/ and generates:
 * - categories-metadata.json (metadata for all categories)
 * - all.json (all props from all categories combined)
 * - Updates constants.ts with the total count
 * 
 * Runs automatically during build
 */

const fs = require('fs');
const path = require('path');

const propDataDir = path.join(__dirname, '../docs/.vitepress/theme/propData');
const outputPath = path.join(propDataDir, 'categories-metadata.json');

function toSlug(value) {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function toLabel(value) {
  return value
    .replace(/[_-]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function extractSubcategories(props) {
  const subMap = new Map();
  props.forEach(prop => {
    if (prop.subcategory) {
      const subSlug = toSlug(prop.subcategory);
      if (!subMap.has(subSlug)) {
        subMap.set(subSlug, { slug: subSlug, label: toLabel(prop.subcategory), count: 0 });
      }
      subMap.get(subSlug).count++;
    }
  });
  return Array.from(subMap.values()).sort((a, b) => a.label.localeCompare(b.label));
}

console.log('üìä Generating categories metadata...');

// Find all JSON files (except metadata, template and all.json)
const files = fs.readdirSync(propDataDir)
  .filter(file => 
    file.endsWith('.json') && 
    !file.startsWith('_') && 
    file !== 'categories-metadata.json' &&
    file !== 'all.json'  // Exclude all.json
  )
  .sort(); // Sort alphabetically for consistent order

console.log(`Found ${files.length} category files`);

const categories = [];
const allProps = []; // Collect all props for all.json
let totalProps = 0;

files.forEach(file => {
  const filePath = path.join(propDataDir, file);
  const slug = file.replace('.json', '');
  const label = toLabel(slug);
  
  try {
    const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    
    // Check if it's new format (with metadata) or old format (just array)
    let props, subcategories;
    
    if (Array.isArray(data)) {
      // Old format: just array of props
      props = data;
      subcategories = extractSubcategories(props);
    } else {
      // New format: with metadata
      props = data.props || [];
      
      // Use defined subcategories from metadata
      if (data.metadata?.subcategories) {
        subcategories = data.metadata.subcategories.map(sub => {
          const subSlug = toSlug(sub.name);
          return {
            slug: subSlug,
            label: toLabel(sub.name),
            count: props.filter(p => toSlug(p.subcategory ?? '') === subSlug).length
          };
        });
      } else {
        // Fallback: extract from props
        subcategories = extractSubcategories(props);
      }
    }

    categories.push({
      slug,
      label,
      count: props.length,
      subcategories: subcategories
    });
    
    // Add all props to the collection for all.json
    allProps.push(...props);
    
    totalProps += props.length;
    
    console.log(`  ‚úì ${label.padEnd(30)} ${props.length.toString().padStart(6)} props`);
  } catch (error) {
    console.error(`  ‚úó Error processing ${file}: ${error.message}`);
    process.exitCode = 1;
  }
});

// Sort categories (Spooni Props first, then alphabetical)
categories.sort((a, b) => {
  if (a.slug === "spooni-props") return -1;
  if (b.slug === "spooni-props") return 1;
  return a.label.localeCompare(b.label);
});

// Sort all props alphabetically by id for consistent order
allProps.sort((a, b) => (a.id || '').localeCompare(b.id || ''));

// Create metadata
const metadata = {
  totalProps: totalProps,
  categories: categories
};

// Write metadata file
try {
  fs.writeFileSync(outputPath, JSON.stringify(metadata, null, 2), 'utf-8');
  console.log('');
  console.log(`‚úÖ Generated categories-metadata.json`);
} catch (error) {
  console.error(`‚ùå Error writing categories-metadata.json: ${error.message}`);
  process.exit(1);
}

// Generate all.json with all props combined
try {
  const allJsonPath = path.join(propDataDir, 'all.json');
  fs.writeFileSync(allJsonPath, JSON.stringify(allProps, null, 2), 'utf-8');
  console.log(`‚úÖ Generated all.json with ${allProps.length} combined props`);
} catch (error) {
  console.error(`‚ùå Error writing all.json: ${error.message}`);
  process.exit(1);
}

// Update constants.ts with the new total
try {
  const constantsPath = path.join(__dirname, '../docs/.vitepress/theme/constants.ts');
  let constantsContent = fs.readFileSync(constantsPath, 'utf-8');
  constantsContent = constantsContent.replace(
    /TOTAL_PROPS_ESTIMATE:\s*\d+,\s*\/\/ Auto-generated by generate-categories-metadata\.js/,
    `TOTAL_PROPS_ESTIMATE: ${totalProps}, // Auto-generated by generate-categories-metadata.js`
  );
  fs.writeFileSync(constantsPath, constantsContent, 'utf-8');
  console.log(`‚úÖ Updated constants.ts with total props count`);
} catch (error) {
  console.error(`‚ùå Error updating constants.ts: ${error.message}`);
  process.exit(1);
}

console.log(`   Total categories: ${categories.length}`);
console.log(`   Total props: ${totalProps}`);
console.log('');

